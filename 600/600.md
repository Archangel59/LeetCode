[题目链接](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)
    
### 600. 不含连续1的非负整数
   给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。
   
### 题解.
    一共有三种解法
    1. 暴力求解(实测golang会超时)
        求不含连续1的非负整数，所以我们可以从1开始dfs
        如果当前的数 x 为奇数, 则后面也不能有1, 所以往后面添0, 即 dfs(x<<1)
        如果当前的数 x 为偶数, 则后面可能为0/1，所以 dfs(x<<1) 和 dfs((x<<1)+1)
        
    2. 数位dp
        别问, 我不会, 我是five. 但刷的题多了就知道是数位dp
        
    3. 斐波那契
        找规律得到 设f(x)=y, 长度为x时, 有y种情况满足 
        1:  2 (0, 1)
        2:  3 (00, 01, 10)
        3:  5 (000, 001, 010, 100, 101)
        4:  8 (0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010)
        ...: ...
        x:  f(x)
        可以得到这是一波斐波那契数列 即 f[x] = f[x-1] + f[x-2]
        
        通过这个规律能得到
        设 x = 10，转换二进制为 (1010) 从左往右进行遍历
        第一个数: 1. 此时比 1000 小的数为 111, 即长度为3的f[3]   ans[1] = f[3] = 5
        第二个数: 0. 没有比 000 小的数                          ans[2] = 0
        第三个数: 1. 此时比 10 小的数为 1, 即长度为1的f[1]       ans[3] = f[1] = 2
        第四个数: 0. 没有比 0 小的数                            ans[4] = 0
        
        而 10 本身是一个合法的数 所以答案+1
        ans = 5 + 0 + 2 + 0 + 1 = 8
        
        那么再来一个不合规的数字
        设 x = 13, 转换为二进制为 (1101)
        第一个数: 1. 长度为3                                  ans[1] = f[3] = 5
        第二个数: 1. 长度为2.                                 ans[2] = f[2] = 3
        第三个数: 0. 因为此前有连续的1,不合法,所以后面无需计算
        ans = 5 + 3 = 8


### code:
[Golang](https://github.com/Archangel59/LeetCode/blob/main/600/600.go)  
[C++](https://github.com/Archangel59/LeetCode/blob/main/600/600.cpp)  

***Date: 2021-09-15***
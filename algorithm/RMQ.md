## RMQ算法浅谈

######~~Timi面试官算你狠~~

***

####题目
```
好了不多BB了，我们来看时间的面试问题。  
给你一个数组, 然后有很多次的query，每次query给一个区间。让查询这个区间内的最小值  

假设数组为[1, 2, 6, 8, 4, 3, 7]  
查询为[2, 5], 那结果应该为子数组[2,6,8,4]中最小值2  
```
***

```
典型的一个RMQ解决. 顺带学习一下
RMQ是一个离线算法，最开始拿到数据后需要花一定时间 (nlogn) 来处理，最终达到 O(1) 的查询  

而RMQ实质上是一个dp位运算

我们设二维数组 dp[i][j] 表示从第i位开始连续 2^j 个数中的最小值。
例如 dp[2][1] 表示从第二位数开始连续两个数的最小值，即2，6中的最小值，所以 dp[2][1] = 2;

我们求dp[i][j]的时候可以把它分成两部分
第一部分是[i, i+(2^j-1)-1]
第二部分是[i+(2^j-1),i+(2^j)-1]
为什么可以这么分呢？其实我们都知道二进制数前一个数是后一个的两倍，那么可以把[i, i+(2^j)-1]通过分成相等的两部分
那么转移方程很容易就写出来了。

dp[i][j] = min(dp[i][j - 1], dp[i + (1 << j - 1)][j - 1])
```
***
给出下列代码

```
void rmq_init() {
    for(int i=1;i<=N;i++)
        dp[i][0]=arr[i];// dp[i][0] 就表示第i个数字本身
    for(int j=1;(1<<j)<=N;j++)
        for(int i=1;i+(1<<j)-1<=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1<<j-1)][j-1]);
}
```
*ps: 注意外层是j, 内层是i*

```
接着是 query 部分, 需要查[l, r]区间内最小数
因为 dp[i][j] 表示从第i位开始连续 2^j 个数中的最小值。
此时 设 k = log2(r-l+1)
则ans[l,r] = min(dp[l][k], dp[r - (1 << k) + 1][k])

那么 dp[l][k] => [l, l + 2^k - 1]
dp[r - (1 << k) + 1][k] => [r - 2^k + 1, r]
所以只需要证明 r - 2^k + 1 <= l + 2^k - 1
移项以后发现改证明成立

所以很轻松可以在 O(1) 内查询出来
```
***
给出查询代码

```
int rmq(int l,int r) {
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1<<k)+1][k]);
}
```
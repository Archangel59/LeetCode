[题目链接](https://leetcode-cn.com/problems/decode-ways-ii/)
    
### 639. 解码方法 II
    一条包含字母 A-Z 的消息通过以下的方式进行了编码：
    
    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26
    要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：
    
    "AAJF" 对应分组 (1 1 10 6)
    "KJF" 对应分组 (11 10 6)
    注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。
    
    除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。
    
    给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
    
    由于答案数目可能非常大，返回对 109 + 7 取余 的结果。 
   
### 题解.
    线性dp, 通过题目要求, 对计算进行分类. 
    首先分为两种情况
    
    1. 取当前字符s[i]
        a. 如果 s[i] 为 *, 那么dp[i] = 9 * dp[i-1]
        b. 如果 s[i] 为 0, 那么没有答案, dp[i] = 0
        c. 对于其他情况 dp[i] = dp[i-1]
        
    2. 取前一个字符以及当前字符 s[i-1], s[i]
        a. 如果 s[i],s[i-1] 均为 *, 那么dp[i] = 15 * dp[i-2]
        b. 如果 s[i-1] 为 *, 那么对s[i]进行分类
            i. 如果s[i] <= 6, 那么dp[i] = 2 * dp[i-2]
            ii.否则 dp[i] = dp[i-2]
        c. 如果 s[i] 为 *, 那么对s[i-1]进行分类
            i. 如果s[i-1] = 1, 那么dp[i] = 9 * dp[i-2]
            ii.如果s[i-1] = 2, 那么dp[i] = 6 * dp[i-2]
            iii. 否则dp[i] = 0
        d. 如果s[i-1]不为0并且s[i-1]s[i] <= 26 即[1,26]的情况, 那么 dp[i] = dp[i-2]
        e. 否则dp[i] = 0
        
    针对上述两种情况, 对答案进行累计求和就是答案.
    
    特别的. 第一个字符的时候只取第一种情况.
    
    由于题目为线性dp, 则可以通过三个变量之间的互相转换解决, 节省开数组的空间消耗
 
### code:
[Golang](https://github.com/Archangel59/LeetCode/blob/main/639/639.go)  

***Date: 2021-09-27***